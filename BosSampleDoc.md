# BOS PC Sample

Описание сцен, базовой логики и игры.

# Определения

Базовая логика (игры) - скрипты и прочие ассеты из **каталога '*Assets/Common*' и сцена в '*Assets/Scenes/InitScene*'**. Для совместимости с другими играми и прочим, **менять не рекомендуется**.

ПО - программа NeuroMD, которая на ПК передает данные датчика в игру и управляет ей.

Окно сборщика - окно для настройки и сборки проекта, вызывается в контекстном меню Unity (*CI -> Build Window*).

# Scenes

Описание сцен. Подробнее о классах, интерфейсах и пр., см. в *Code*. **Запуск игры только через InitScene**

## InitScene

Сцена инициализации. Выполняет инициализацию основных интерфейсов игры, проверку подключения к ПО либо его симуляции (если включено в окне сборщика). Также выполняет роль загрузочного экрана.

На экран выводится версия игры (дата и время сборки проекта) и изображение-заставку (изначально пустой фон).

    NOTE: Требуемые для игры сущности создаются и настраиваются на сцене с использованием DontDestroyOnLoad.
    Доступ к ним предусматривается через `GameEntryPointBase` (см. *Game Scene*).

## GameScene

Сцена игры. Содержит игру и **обязательный** GameObject с `GameEntryPointBase`. Т. е. для новой игры **потребуется добавить в вашу сцену** наследника `GameEntryPointBase`.

`GameEntryPointBase` должен быть один и предоставляет доступ к:
 - пауза, управляется командой от ПО;
 - таймер игры (понадобится для получения рамки);
 - количество игроков (доступных датчиков в ПО);
 - интерфейс датчика *IDevice* для конкретного id (номер датчика);
 - методы *Initialize*/*DeInitialize* (для наследников), гарантирующие готовность базовой логики (см. предыдущие пункты).

В данном проекте наследовались через `GameEntryPoint`, добавив старт ui, логики игроков. Дополнительно возможно использовать различные `GameControllerBase`, которые могут расширить логику игры, имея доступ к `GameEntryPoint`.

Логика вашей игры, которая **требует доступа** к `GameEntryPointBase` (равно как и наследнику) и **начинается** при старте сцены игры, должна настраиваться в `GameEntryPointBase.[Initialize | DeInitialize]` и `GameControllerBase.[Init | DeInit]`.

Например, GameObject находится на сцене игры с ее старта (т. е. не создается после инициализации `GameEntryPoint`), и вашему скрипту на нем нужно получить что-то из *IDevice* в *Awake* или *Start*, будут проблемы. А, например, для создаваемого из префаба в процесcе игры снаряда, ошибок не будет (но тут рекомендуется добавить Init для снаряда, вызываемый в месте его создания).

    NOTE: В данном проекте в ui игроков возможно вывести текущие значения столбика/рамки и статус рамки.
    Для этого нажмите D (работает при выбранном '*Development*' в окне сборщика).

# Code

Базовая логика игры оборачивает доступные данные от ПО, инициализацию и прочее. Т. е. сама игра не сильно зависит от ПО, все взаимодействия происходят через `GameEntryPointBase`

## `GameEntryPointBase` и его наследник. Доступ к базовой логике

Точка входа в игру для базовой логики. Содержит:
 - `GameStatus` `GameStatus` - состояние игры, отправляемое из ПО;
 - int `PlayersCount` - количество датчиков из ПО;
 - double `GameTime` - время игры (потребуется для рамки);
 - `IDevice` `GetDevice(int id)` - интерфейс работы с датчиком из ПО;
 - *abstract void Initialize() и DeInitialize()* - вызываются после готовности базовой логики и до ее удаления соответственно.

В данном проекте используется через `GameEntryPoint`, который расширяет функционал следующим:
 - GameScreen `GameScreen` - экран игры, общие меню и т. д.;
 - GameHUD `GameHUD` - ui игроков (рамка, столбик) и их данных;
 - PlayersManager `Players` - логика игроков (использует `IDevice`);
 - *[SerializeField]* GameControllerBase[] `_gameControllers` - дополнительная логика игры с доступом к `GameEntryPoint`, через *abstract* Init/DeInit() обеспечивает готовность базовой логики (в проекте не используется).

## `GameStatus`. Управляемый в ПО статус

Содержит:
- event Action<bool> `GamePauseChanged` - событие изменения паузы;
- bool `IsPaused` - последнее значения паузы;

Изменение паузы происходит по команде из ПО.

    NOTE: Также по может послать команду выхода из игры.
    Базовая логика автоматически закроет ее, это можно отследить через GameEntryPointBase.DeInitialize().
    Если игра закроется сама, то ПО определит это (не гарантируется при открытии в Unity Editor).

## `IDevice`. Работа с датчиком и его данные

Интерфейс для работы с датчиком из ПО, возможно получить через *GameEntryPointBase.GetDevice(int id)* (id - номер датчика).

Содержит (все данные приходят из ПО):
 - int `Id` - номер датчика (от 0 до *GameEntryPointBase.PlayersCount*);
 - int `ReadValue()` - значение столбика (0..100);
 - float `ReadValueF()` - значение столбика (0..100);
 - EFrameZoneType `ReadColorGroup()` - тип цвета столбика, доступные варианты:
   * NOTE: столбик не близко к рамке - значение ниже/выше, но не дальше x, значения x скрыто в ПО.
   + NULL - нет данных или ошибка;
   + RED_DOWN -  ниже рамки, но не близко;
   + ORANGE_DOWN - ниже рамки, но близко;
   + GREEN - в рамке (включая равенство с границами);
   + ORANGE_UP - выше рамки, но близко;
   + RED_UP - выше рамки, но не близко;
 - EFrameStatus `ReadFrame(double forTimeSec, out int bottom, out int top)` - получение значений рамки (в out). Возвращает тип рамки, доступные варианты:
   + NO_PERIOD - рамка статична и меняется в ПО руками, т. е. нет смысла передавать forTimeSec+offsetSec;
   + WAIT_PERIOD - рамка периодическая (см. след. п.), но ПО еще не передало все данные для этого, т. е. получить рамку в будущее не получится;
   + FULL_PERIOD - рамка периодическая и получены все данные для ее работы, т. е. мы можем получить рамку в будущее (orTimeSec+offsetSec);
 - int `ReadBottom(double forTimeSec)` - вернет нижнюю границу рамки;
 - int `ReadTop(double forTimeSec)` - вернет верхнюю границу рамки;

#### Подробнее параметре `forTimeSec` при получении рамки

В некоторых играх может понадобиться получить рамку в будущем. Для этого игре требуется набрать данные от ПО за полный период рамки (т. е. дождаться начала повторения периода и набора данных до его конца). Но **рамка в будущем** работает **только при *EFrameStatus.NO_PERIOD***.

    Пример для такого использования - игра самолет, в которой объекты спавнятся правее игрока по рамке в будущем, чтобы, на момент их встречи с игроком, значения столбика и рамки (созданных по ней объектов) совпадало.
    Иначе в результатах игры, которые предоставляет ПО, один из графиков будет отображать несоответствия столбика и рамки, хотя в игре мы все отлично выполняли.

Для получения рамки, т. е. использования методов `ReadFrame(...)`/`ReadBottom(...)`/`ReadTop(...)`, мы передаем `forTimeSec`. Это время, на момент которого получим значения рамки, его можно получить через *GameEntryPointBase.GameTime*.

**Если нам не важно получение рамки в будущем** (см. пример выше), то можем игнорировать результат `ReadFrame(...)`, любые из 3 упомянутых методов для получения рамки и всегда передавать `forTimeSec` = *GameEntryPointBase.GameTime*.

**Иначе** получаем рамку через **только через** `ReadFrame(...)`, проверяя результат (EFrameStatus). Тогда:
 - при *EFrameStatus.NO_PERIOD* ничего дополнительного не делаем (не нужно ждать периода и не получить рамку в будущее);
 - при *EFrameStatus.WAIT_PERIOD* мы ждем рамку, рекомендуется в это время не давать набирать игровые очки и пр.;
 - при *EFrameStatus.FULL_PERIOD* рамка в будущее работает, можем не ограничивать игру (см. предыдущий пункт).

## `Player*`. Старт игроков. Получение и использование данных датчика в данном проекте

`PlayerController` создается из `PlayerManager`. Логика следующая:
 - `PlayerManager` создает нужное количество игроков:
   + проверяет `GameEntryPointBase.PlayersCount` для определения количества игроков (id *0...PlayersCount*);
   + обращается к `GameHUD` для получения (создаваемого в `GameHUD`) ui конкретного игрока;
   + Получает от `GameEntryPointBase` интерфейс датчика для конкретного игрока (id) `IDevice`
   + создает `PlayerController` и передает ui и интерфейс датчика конкретного игрока;
   + сохраняет **игроков** для дальнейшего **обновления их данных** через *PlayerManager.Uptate* (MonoBehaviour);
 - обновление конкретного игрока вызывает `PlayerController.UpdateData()`.

В данном проекте получение и использование данных датчиков происходит в `PlayerController.UpdateData(double gameTime)`. Из `IDevice` используются:
 - `ReadValue()` - значение столбика;
 - `ReadColorGroup()` - цвет столбика;
 - `ReadFrame(gameTime, ...)` - значения рамки и ее статус (см. `EFrameStatus`).

Далее данные передаются в ui игрока в `_view.UpdateData(value, fBottom, fTop, fZoneType)` и статус рамки в `_view.UpdateFrameStatus(fStatus != EFrameStatus.WAIT_PERIOD)` (т е норм. статус рамки если статичная или готовая периодическая).

# Режим симуляции

В режиме симуляции возможно запустить игру без использования ПО. Т. е. команды и данные из него симулируются базовой логикой. Симуляция рассчитана на 4 датчика.

    NOTE: Если выбрать не '*Development*' в окне сборщика, то симуляцию включить не получится.

Для включения или выключения симуляции требуется в окне сборщика нажать на "Is Control App Simulate" и "Save Settings".

    NOTE: Без нажатия "Save Settings" не переключится* (как и прочие настройки).

Для управления симуляцией используется клавиатура, при старте игры в лог выводится подсказка:

    Simulate controls:
        MoveFrameUpKey: Keypad8
        MoveFrameDownKey: Keypad2
        ResizeFrameUpKey: KeypadMultiply
        ResizeFrameDownKey: KeypadDivide
        MoveValueUpKey: Keypad6
        MoveValueDownKey: Keypad4
        SwitchServerPauseKey: P
        SwitchServerStopKey: Q
